// Powered by nChain's Nakasendo libraries.
// See LICENSE.txt in project root for licensing information.

#ifndef _NCHAIN_SDK_SEEDER_H_
#define _NCHAIN_SDK_SEEDER_H_

#include <iterator>

#include <randutils/randutils.hpp>

namespace nakasendo {

/**
* A definition of supported sources of randomness. A user can provide it's own implementation of random source class to
* instantiate KeyECSecp256k1 object (such a class should expose void generate(Iterator start, Iterator end) method and
* a constructor with a seed if it is desired).
*/

template<typename Generator,
         typename RandomType = uint32_t, int SEED_SIZE = 32,
         typename Enable = typename std::enable_if<std::is_integral<RandomType>::value>::type,
         typename... Params>
class RandomRangeGenerator
{
    using IRandomType = RandomType;
public:
    /// Provided seeds must be at least this many bytes
    static constexpr uint8_t MINIMUM_SEED_SIZE = SEED_SIZE;     /* in bytes */

    /// Default constructor
    RandomRangeGenerator() = default;

    RandomRangeGenerator(const RandomRangeGenerator&) = default;
    RandomRangeGenerator& operator=(const RandomRangeGenerator&) = default;

    RandomRangeGenerator(RandomRangeGenerator&& other):
        mSeeder(std::move(other.mSeeder))
    {}

    RandomRangeGenerator& operator=(RandomRangeGenerator&& other){
        if( this == &other )
            return *this;

        mSeeder = std::move(other.mSeeder);

        return *this;
    }

    /**
     * @brief RandomRangeGenerator Initialize RNG generator with a user's seed (deterministic initialization of the seeder).
     * @param seedBegin iterator pointing at the start of seed sequence
     * @param seedEnd iterator pointing at the end of seed sequence
     */
    template<typename Range>
    RandomRangeGenerator(const Range& seed, Params&&... params)                                 /* seeded constructor */
    {
        auto seedSrc = initSeed(std::begin(seed), std::end(seed));
        cSeed( seedSrc.first, seedSrc.second, std::forward<Params>(params)... );
    }

    template<typename Iter>
    RandomRangeGenerator(const Iter begin, const Iter end, Params... params)                                 /* seeded constructor */
    {
        auto seedSrc = initSeed(begin, end);
        cSeed( seedSrc.first, seedSrc.second, std::forward<Params>(params)... );
    }

    template<typename Iter>
    size_t generate(Iter begin, Iter end, Params&&... params){
        if( begin == end)
            return 0;

        auto result = convert<IRandomType>(begin, end);
        auto size = std::distance(begin, end);

        cGenerate(result.first, result.second, std::forward<Params>(params)...);
        return size - size % sizeof(IRandomType);
    }

    /**
     * @brief generate a pseudo-random sequence of bytes.
     * @param first iterator pointing at the start of the sequence where generated data should be stored
     * @param last iterator pointing at the start of the sequence where generated data should be stored
     * @return number of generated bytes divisible by sizeof(RandomType)
     */
    template<typename Range>
    size_t generate(Range& range, Params&&... params){
        return generate(std::begin(range), std::end(range), std::forward<Params>(params)... );
    }    

private:
    /* Generator dependent operations */
    void cSeed(IRandomType* first, IRandomType* last, Params&&...);
    void cGenerate(IRandomType* first, IRandomType* last, Params&&...);
    /********************************/

    template<typename Iter>
    auto initSeed(const Iter& begin, const Iter& end)
    {
        checkSeedSize(begin, end);
        auto seedSrc = convert<IRandomType>(begin, end);
        return seedSrc;
    }

    void asserts()const{
        static_assert(std::is_integral<RandomType>::value, "Random data type is not integral");
        static_assert(SEED_SIZE >= 32, "Seed size is too small");
    }

    template<typename Iter>
    size_t checkSeedSize(const Iter& begin, const Iter& end) const{
        // Check the source seed is large enough
        size_t result = std::distance(begin, end) * sizeof( typename Iter::value_type ); /* in bytes */
        if( result < MINIMUM_SEED_SIZE ){
            throw std::runtime_error("Seed size needs to be at least " + std::to_string(MINIMUM_SEED_SIZE));
        }
        return result / sizeof( RandomType ); /* in random numbers */
    }

    template<typename ConversionTo, typename ConversionFrom>
    std::pair<ConversionTo*, ConversionTo*> convert(const ConversionFrom& begin, const ConversionFrom& end) const{
        std::pair<ConversionTo*, ConversionTo*> result;
        decltype(&*begin) pBegin = &*begin;
        decltype(&*end) pEnd = pBegin + std::distance(begin, end);

        result.first = (ConversionTo*)pBegin;
        result.second = result.first + ( pEnd - pBegin) / sizeof( ConversionTo );
        return result;
    }

   Generator mSeeder;
};

using RandutilsSeed = RandomRangeGenerator<randutils::mt19937_rng>;
using RandutilsSeedSTL = RandomRangeGenerator<std::mt19937>;

}
#endif // _NCHAIN_SDK_SEEDER_H_
